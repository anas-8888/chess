import jwt from 'jsonwebtoken';
import config from '../../config/index.js';
import User from '../models/User.js';
import Invite from '../models/Invite.js';
import Game from '../models/Game.js';
import { Op } from 'sequelize';
import logger from '../utils/logger.js';

// Store active user connections - ุชุญุณูู ูุชุชุจุน ุฌููุน ุงูุงุชุตุงูุงุช ููู ูุณุชุฎุฏู
const activeUsers = new Map(); // userId -> Set of socketIds
const activeGames = {};
const gameTimers = {};

// ูุชุบูุฑ ูุชุฎุฒูู ุจูุงูุงุช ุงููุคูุช ูู ุงูุฐุงูุฑุฉ
const gameTimerData = new Map(); // { gameId: { whiteTimeLeft, blackTimeLeft, currentTurn, game } }

// Store previous stats for comparison
let previousStats = { totalUsers: 0, totalConnections: 0 };

// Configuration for logging
const LOG_CONFIG = {
  showDetailedConnections: false, // ุชุนุทูู ุงูุฑุณุงุฆู ุงูุชูุตูููุฉ ููุงุชุตุงูุงุช
  showStatusUpdates: true,        // ุฅุธูุงุฑ ุชุญุฏูุซุงุช ุงูุญุงูุฉ
  showStats: true                // ุฅุธูุงุฑ ุงูุฅุญุตุงุฆูุงุช
};

// Function to update logging configuration
export function updateLogConfig(newConfig) {
  Object.assign(LOG_CONFIG, newConfig);
  logger.info('ุชู ุชุญุฏูุซ ุฅุนุฏุงุฏุงุช ุงูุชุณุฌูู', LOG_CONFIG);
}

// Function to get current log config
export function getLogConfig() {
  return { ...LOG_CONFIG };
}

// Function to disable all detailed logging
export function disableDetailedLogging() {
  updateLogConfig({
    showDetailedConnections: false,
    showStatusUpdates: false,
    showStats: false
  });
  logger.info('ุชู ุชุนุทูู ุฌููุน ุงูุฑุณุงุฆู ุงูุชูุตูููุฉ');
}

// Function to enable minimal logging (only important events)
export function enableMinimalLogging() {
  updateLogConfig({
    showDetailedConnections: false,
    showStatusUpdates: true,  // ุฅุธูุงุฑ ููุท ุชุญุฏูุซุงุช ุงูุญุงูุฉ ุงููููุฉ
    showStats: false
  });
  logger.info('ุชู ุชูุนูู ุงูุชุณุฌูู ุงูุจุณูุท (ุงูุฃุญุฏุงุซ ุงููููุฉ ููุท)');
}

// Authentication helper
export function authenticateSocket(socket) {
  try {
    // Try JWT first
    const token = socket.handshake.auth.token || socket.handshake.query.token;
    if (token) {
      const decoded = jwt.verify(token, config.jwt.secret);
      return decoded.user_id;
    }
    
    // Fallback to userId in query
    const userId = parseInt(socket.handshake.query.userId);
    if (!userId || isNaN(userId)) {
      throw new Error('Authentication required');
    }
    
    return userId;
  } catch (error) {
    throw new Error('Authentication failed');
  }
}

// User connection management
export function addUserConnection(userId, socketId) {
  if (!activeUsers.has(userId)) {
    activeUsers.set(userId, new Set());
  }
  activeUsers.get(userId).add(socketId);
  
  const totalConnections = activeUsers.get(userId).size;
  
  // ุชุญุฏูุซ ุญุงูุฉ ุงููุณุชุฎุฏู ุฅูู online ุนูุฏ ุฃูู ุงุชุตุงู
  if (totalConnections === 1) {
    updateUserStatus(userId, 'online').catch(error => {
      logger.error('ุฎุทุฃ ูู ุชุญุฏูุซ ุญุงูุฉ ุงููุณุชุฎุฏู ุฅูู online', error);
    });
  }
  
  // ุทุจุงุนุฉ ุฑุณุงูุฉ ููุท ุนูุฏ ุฃูู ุงุชุตุงู ุฃู ุนูุฏ ุชุบููุฑ ุนุฏุฏ ุงูุงุชุตุงูุงุช
  if (LOG_CONFIG.showDetailedConnections) {
    if (totalConnections === 1) {
      logger.debug(`ุงุชุตุงู ุฌุฏูุฏ ูููุณุชุฎุฏู ${userId} (${socketId})`);
    } else {
      logger.debug(`ุงุชุตุงู ุฅุถุงูู ูููุณุชุฎุฏู ${userId} - ุฅุฌูุงูู ุงูุงุชุตุงูุงุช: ${totalConnections}`);
    }
  }
}

export function removeUserConnection(userId, socketId) {
  if (activeUsers.has(userId)) {
    activeUsers.get(userId).delete(socketId);
    
    const remainingConnections = activeUsers.get(userId).size;
    
    // ุฅุฐุง ูู ูุชุจู ุฃู ุงุชุตุงูุงุชุ ุงุญุฐู ุงููุณุชุฎุฏู ูู ุงููุงุฆูุฉ ูุชุญุฏูุซ ุงูุญุงูุฉ ุฅูู offline
    if (remainingConnections === 0) {
      activeUsers.delete(userId);
      logger.debug(`โ ุชู ูุทุน ุฌููุน ุงุชุตุงูุงุช ุงููุณุชุฎุฏู ${userId}`);
      
      // ุชุญุฏูุซ ุญุงูุฉ ุงููุณุชุฎุฏู ุฅูู offline ุนูุฏ ูุทุน ุขุฎุฑ ุงุชุตุงู
      updateUserStatus(userId, 'offline').catch(error => {
        logger.error('ุฎุทุฃ ูู ุชุญุฏูุซ ุญุงูุฉ ุงููุณุชุฎุฏู ุฅูู offline', error);
      });
    } else if (LOG_CONFIG.showDetailedConnections) {
      logger.debug(`โ ุงุชุตุงู ุฃูู ูููุณุชุฎุฏู ${userId} - ุงูุงุชุตุงูุงุช ุงููุชุจููุฉ: ${remainingConnections}`);
    }
  }
}

export function getUserConnections(userId) {
  return activeUsers.get(userId) || new Set();
}

export function isUserOnline(userId) {
  return activeUsers.has(userId) && activeUsers.get(userId).size > 0;
}

// User status management
export async function updateUserStatus(userId, status) {
  try {
    if (!userId || !status) {
      logger.error('ุจูุงูุงุช ุชุญุฏูุซ ุญุงูุฉ ุงููุณุชุฎุฏู ุบูุฑ ููุชููุฉ:', { userId, status });
      return;
    }
    
    // ุงูุชุญูู ูู ุตุญุฉ ุงูุญุงูุฉ ุญุณุจ ูููุฐุฌ User
    const validStatuses = ['online', 'offline', 'in-game'];
    if (!validStatuses.includes(status)) {
      logger.error('ุญุงูุฉ ูุณุชุฎุฏู ุบูุฑ ุตุญูุญุฉ:', status);
      return;
    }
    
    // ุงูุชุญูู ูู ูุฌูุฏ ุงููุณุชุฎุฏู ุฃููุงู
    const user = await User.findByPk(userId);
    if (!user) {
      logger.error('ุงููุณุชุฎุฏู ุบูุฑ ููุฌูุฏ:', userId);
      return;
    }
    
    // ุงูุชุญูู ูู ุงูุญุงูุฉ ุงูุญุงููุฉ ูุจู ุงูุชุญุฏูุซ
    if (user.state === status) {
      logger.debug(`ุงููุณุชุฎุฏู ${userId} ุญุงูุชู ${status} ุจุงููุนูุ ุชุฎุทู ุงูุชุญุฏูุซ`);
      return;
    }
    
    // ุชุญุฏูุซ ุงูุญุงูุฉ ููุท ุฅุฐุง ุชุบูุฑุช ูุนููุงู
    const oldStatus = user.state;
    await User.update(
      { state: status },
      { where: { user_id: userId } }
    );
    
    const connectionsCount = getUserConnections(userId).size;
    
    // ุทุจุงุนุฉ ุฑุณุงุฆู ูุญุณูุฉ ููุท ุฅุฐุง ูุงู ููุนูุงู
    if (LOG_CONFIG.showStatusUpdates) {
      if (status === 'online' && connectionsCount > 0) {
        logger.info(`๐ข ุงููุณุชุฎุฏู ${userId} ูุชุตู ุงูุขู (${connectionsCount} ุงุชุตุงู)`);
      } else if (status === 'offline') {
        logger.info(`๐ด ุงููุณุชุฎุฏู ${userId} ุบูุฑ ูุชุตู`);
      } else if (status === 'in-game') {
        logger.info(`๐ฎ ุงููุณุชุฎุฏู ${userId} ูู ูุจุงุฑุงุฉ`);
      }
    }
    
    // ุฅุฑุณุงู ุชุญุฏูุซ ุงูุญุงูุฉ ูุฌููุน ุฃุตุฏูุงุก ุงููุณุชุฎุฏู ููุท ุฅุฐุง ุชุบูุฑุช ุงูุญุงูุฉ
    await broadcastFriendStatusUpdate(userId, status);
    
    // ุชุณุฌูู ุงูุชุญุฏูุซ ูุฑุฉ ูุงุญุฏุฉ ููุท
    logger.debug(`ุชู ุชุญุฏูุซ ุญุงูุฉ ุงููุณุชุฎุฏู ${userId} ูู ${oldStatus} ุฅูู ${status}`);
  } catch (error) {
    logger.error('Error updating user status:', error);
  }
}

// ุฏุงูุฉ ูุฅุฑุณุงู ุญุงูุฉ ุงูุฃุตุฏูุงุก ูููุณุชุฎุฏู ุงูุฌุฏูุฏ
export async function sendFriendsStatusToUser(socket, userId) {
  try {
    // ุงุณุชูุฑุงุฏ ูููุฐุฌ Friend
    const Friend = await import('../models/Friend.js');
    
    // ุงูุจุญุซ ุนู ุฌููุน ุฃุตุฏูุงุก ุงููุณุชุฎุฏู
    const friends = await Friend.default.findAll({
      where: {
        [Op.or]: [
          { user_id: userId },
          { friend_user_id: userId }
        ],
        status: 'accepted'
      }
    });
    
    // ุฅุฑุณุงู ุญุงูุฉ ูู ุตุฏูู
    for (const friend of friends) {
      const friendUserId = friend.user_id === userId ? friend.friend_user_id : friend.user_id;
      
      // ุงูุญุตูู ุนูู ุญุงูุฉ ุงูุตุฏูู ูู ูุงุนุฏุฉ ุงูุจูุงูุงุช
      const friendUser = await User.findByPk(friendUserId);
      if (friendUser) {
        socket.emit('friendStatusChanged', {
          userId: friendUserId,
          status: friendUser.state,
          timestamp: new Date()
        });
      }
    }
    
    logger.debug(`๐ก ุชู ุฅุฑุณุงู ุญุงูุฉ ${friends.length} ุตุฏูู ูููุณุชุฎุฏู ${userId}`);
  } catch (error) {
    logger.error('ุฎุทุฃ ูู ุฅุฑุณุงู ุญุงูุฉ ุงูุฃุตุฏูุงุก:', error);
  }
}

// ุฏุงูุฉ ูุฅุฑุณุงู ุชุญุฏูุซ ุญุงูุฉ ุงููุณุชุฎุฏู ูุฌููุน ุฃุตุฏูุงุฆู
async function broadcastFriendStatusUpdate(userId, status) {
  try {
    // ุงุณุชูุฑุงุฏ ูููุฐุฌ Friend
    const Friend = await import('../models/Friend.js');
    
    // ุงูุจุญุซ ุนู ุฌููุน ุฃุตุฏูุงุก ุงููุณุชุฎุฏู
    const friends = await Friend.default.findAll({
      where: {
        [Op.or]: [
          { user_id: userId },
          { friend_user_id: userId }
        ],
        status: 'accepted'
      }
    });
    
    // ุงูุชุญูู ูู ูุฌูุฏ ุฃุตุฏูุงุก ูุจู ุงูุฅุฑุณุงู
    if (friends.length === 0) {
      logger.debug(`ุงููุณุชุฎุฏู ${userId} ููุณ ูู ุฃุตุฏูุงุกุ ุชุฎุทู ุฅุฑุณุงู ุชุญุฏูุซ ุงูุญุงูุฉ`);
      return;
    }
    
    // ุฅุฑุณุงู ุงูุชุญุฏูุซ ููู ุตุฏูู
    let sentCount = 0;
    for (const friend of friends) {
      const friendUserId = friend.user_id === userId ? friend.friend_user_id : friend.user_id;
      
      // ุฅุฑุณุงู ุงูุชุญุฏูุซ ุนุจุฑ Socket.IO
      const io = global.io;
      if (io) {
        io.to(`user_${friendUserId}`).emit('friendStatusChanged', {
          userId: userId,
          status: status,
          timestamp: new Date()
        });
        sentCount++;
      }
    }
    
    if (sentCount > 0) {
      logger.debug(`๐ก ุชู ุฅุฑุณุงู ุชุญุฏูุซ ุญุงูุฉ ุงููุณุชุฎุฏู ${userId} (${status}) ูู ${sentCount} ุตุฏูู`);
    } else {
      logger.debug(`ูู ูุชู ุฅุฑุณุงู ุฃู ุชุญุฏูุซุงุช ูููุณุชุฎุฏู ${userId} (${status})`);
    }
  } catch (error) {
    logger.error('ุฎุทุฃ ูู ุฅุฑุณุงู ุชุญุฏูุซ ุญุงูุฉ ุงูุฃุตุฏูุงุก:', error);
  }
}

// Game creation helpers
export async function createGame(invite) {
  try {
    // ุชุญุฏูุฏ ูู ููุนุจ ุจุงูุฃุจูุถ (ุนุดูุงุฆูุงู)
    const isWhiteRandom = Math.random() < 0.5;
    const whiteUserId = isWhiteRandom ? invite.from_user_id : invite.to_user_id;
    const blackUserId = isWhiteRandom ? invite.to_user_id : invite.from_user_id;
    
    // ุฅูุดุงุก ุงููุจุงุฑุงุฉ ูุน ุงูุญููู ุงูุตุญูุญุฉ ุญุณุจ ูููุฐุฌ Game ุงูุฌุฏูุฏ
    const game = await Game.create({
      white_player_id: whiteUserId,
      black_player_id: blackUserId,
      started_by_user_id: invite.from_user_id,
      game_type: invite.game_type,
      initial_time: 600, // 10 minutes in seconds
      white_time_left: 600,
      black_time_left: 600,
      white_play_method: invite.play_method,
      black_play_method: invite.play_method,
      current_fen: 'startpos',
      status: 'active',
      current_turn: 'white'
    });
    
    logger.info('ุชู ุฅูุดุงุก ูุจุงุฑุงุฉ ุฌุฏูุฏุฉ:', {
      gameId: game.id,
      whiteUserId: whiteUserId,
      blackUserId: blackUserId,
      playMethod: invite.play_method,
      gameType: invite.game_type,
      initialTime: game.initial_time,
      whiteTimeLeft: game.white_time_left,
      blackTimeLeft: game.black_time_left,
      currentTurn: game.current_turn
    });
    
    return game;
  } catch (error) {
    logger.error('ุฎุทุฃ ูู ุฅูุดุงุก ุงููุจุงุฑุงุฉ:', error);
    throw error;
  }
}

export async function createGameWithMethods(invite) {
  try {
    // ุชุญุฏูุฏ ูู ููุนุจ ุจุงูุฃุจูุถ (ุนุดูุงุฆูุงู)
    const isWhiteRandom = Math.random() < 0.5;
    const whiteUserId = isWhiteRandom ? invite.from_user_id : invite.to_user_id;
    const blackUserId = isWhiteRandom ? invite.to_user_id : invite.from_user_id;
    
    // ุชุญุฏูุฏ ุทุฑููุชู ุงููุนุจ ููู ูุงุนุจ
    const whitePlayMethod = isWhiteRandom ? invite.play_method : invite.play_method;
    const blackPlayMethod = isWhiteRandom ? invite.play_method : invite.play_method;
    
    // ุฅูุดุงุก ุงููุจุงุฑุงุฉ ูุน ุงูุญููู ุงูุตุญูุญุฉ ุญุณุจ ูููุฐุฌ Game ุงูุฌุฏูุฏ
    const game = await Game.create({
      white_player_id: whiteUserId,
      black_player_id: blackUserId,
      started_by_user_id: invite.from_user_id,
      game_type: invite.game_type,
      initial_time: 600, // 10 minutes in seconds
      white_time_left: 600,
      black_time_left: 600,
      white_play_method: whitePlayMethod,
      black_play_method: blackPlayMethod,
      current_fen: 'startpos',
      status: 'active',
      current_turn: 'white'
    });
    
    logger.info('ุชู ุฅูุดุงุก ูุจุงุฑุงุฉ ุฌุฏูุฏุฉ ูุน ุทุฑููุชู ุงููุนุจ:', {
      gameId: game.id,
      whiteUserId: whiteUserId,
      blackUserId: blackUserId,
      whitePlayMethod: whitePlayMethod,
      blackPlayMethod: blackPlayMethod,
      gameType: invite.game_type,
      initialTime: game.initial_time,
      whiteTimeLeft: game.white_time_left,
      blackTimeLeft: game.black_time_left,
      currentTurn: game.current_turn
    });
    
    return game;
  } catch (error) {
    logger.error('ุฎุทุฃ ูู ุฅูุดุงุก ุงููุจุงุฑุงุฉ ูุน ุทุฑููุชู ุงููุนุจ:', error);
    throw error;
  }
}

// Invite management helpers
export async function handleGameInvite(socket, nsp, userId, { toUserId, gameType, playMethod }) {
  try {
    logger.info('ุฅุฑุณุงู ุฏุนูุฉ ูุนุจ:', { fromUserId: userId, toUserId, gameType, playMethod });

    // ูุญุต ุงูุจูุงูุงุช ุงููุทููุจุฉ
    if (!toUserId || !gameType || !playMethod) {
      return socket.emit('error', { message: 'ุจูุงูุงุช ุงูุฏุนูุฉ ุบูุฑ ููุชููุฉ' });
    }

    // Check if recipient exists and is online
    const recipient = await User.findByPk(toUserId);
    if (!recipient) {
      return socket.emit('error', { message: 'ุงููุณุชุฎุฏู ุบูุฑ ููุฌูุฏ' });
    }

    // Check recipient's current status
    if (recipient.state === 'offline') {
      return socket.emit('error', { message: 'ุงููุณุชุฎุฏู ุบูุฑ ูุชุตู ุญุงููุงู' });
    }

    if (recipient.state === 'in-game') {
      return socket.emit('error', { message: 'ุงููุณุชุฎุฏู ูุดุบูู ูู ูุจุงุฑุงุฉ ุฃุฎุฑู' });
    }

    // ูุญุต ุญุงูุฉ ุงููุฑุณู ุฃูุถุงู
    const sender = await User.findByPk(userId);
    if (!sender) {
      return socket.emit('error', { message: 'ุฎุทุฃ ูู ุงููุตุงุฏูุฉ' });
    }

    if (sender.state === 'offline') {
      return socket.emit('error', { message: 'ูุฌุจ ุฃู ุชููู ูุชุตูุงู ูุฅุฑุณุงู ุฏุนูุฉ' });
    }

    if (sender.state === 'in-game') {
      return socket.emit('error', { message: 'ูุง ูููู ุฅุฑุณุงู ุฏุนูุฉ ุฃุซูุงุก ุงููุนุจ' });
    }

    // Check if there's already a pending invite
    const existingInvite = await Invite.findOne({
      where: {
        from_user_id: userId,
        to_user_id: toUserId,
        status: {
          [Op.or]: ['pending', null]
        },
      },
    });

    if (existingInvite) {
      return socket.emit('error', { message: 'ููุฌุฏ ุฏุนูุฉ ูุนููุฉ ุจุงููุนู ููุฐุง ุงููุณุชุฎุฏู' });
    }

    // Create invite in database with ุงูุญููู ุงูุตุญูุญุฉ ุญุณุจ ูููุฐุฌ Invite
    const invite = await Invite.create({
      from_user_id: userId,
      to_user_id: toUserId,
      status: 'pending', // ุงุณุชุฎุฏุงู ุงููููุฉ ุงูุงูุชุฑุงุถูุฉ ุจุฏูุงู ูู null
      game_type: gameType,
      play_method: playMethod,
      date_time: new Date(),
      expires_at: new Date(Date.now() + 60 * 60 * 1000), // 1 hour
    });

    // Broadcast to recipient
    nsp.to(`user::${toUserId}`).emit('inviteCreated', {
      invite: {
        id: invite.id,
        from_user_id: invite.from_user_id,
        to_user_id: invite.to_user_id,
        game_type: invite.game_type,
        play_method: invite.play_method,
        status: invite.status,
        date_time: invite.date_time,
        expires_at: invite.expires_at,
      },
    });

    // Confirm to sender
    socket.emit('gameInviteSent', { success: true, inviteId: invite.id });
    
    logger.info('ุชู ุฅุฑุณุงู ุฏุนูุฉ ุจูุฌุงุญ:', invite.id);
  } catch (error) {
    logger.error('ุฎุทุฃ ูู ุฅุฑุณุงู ุฏุนูุฉ ูุนุจ:', error);
    socket.emit('error', { message: error.message || 'ูุดู ูู ุฅุฑุณุงู ุงูุฏุนูุฉ' });
  }
}

export async function handleInviteResponse(socket, nsp, userId, { inviteId, response }) {
  try {
    logger.info('ุฑุฏ ุนูู ุฏุนูุฉ ูุนุจ:', { inviteId, response, userId });
    
    // ูุญุต ุงูุจูุงูุงุช ุงููุทููุจุฉ
    if (!inviteId || !response) {
      return socket.emit('error', { message: 'ุจูุงูุงุช ุงูุฑุฏ ุบูุฑ ููุชููุฉ' });
    }
    
    const invite = await Invite.findByPk(inviteId);
    if (!invite) {
      return socket.emit('error', { message: 'Invite not found' });
    }

    if (invite.to_user_id !== userId) {
      return socket.emit('error', { message: 'Not authorized' });
    }

    // ูุญุต ุตูุงุญูุฉ ุงูุฏุนูุฉ
    const now = new Date();
    const inviteDate = new Date(invite.date_time);
    const oneHourAgo = new Date(now.getTime() - 60 * 60 * 1000);
    
    if (inviteDate.getTime() < oneHourAgo.getTime()) {
      return socket.emit('error', { message: 'ุงูุชูุช ุตูุงุญูุฉ ุงูุฏุนูุฉ' });
    }

    // Update invite status
    await invite.update({ status: response });

    // Notify sender
    nsp.to(`user::${invite.from_user_id}`).emit('gameInviteResponse', {
      inviteId,
      response,
      fromUserId: invite.to_user_id,
    });

    // If accepted, create game and update player statuses
    if (response === 'accepted') {
      await invite.update({ status: 'accepted' });
      
      // Create the game
      const game = await createGame(invite);
      
      logger.info(`Game created with ID: ${game.id}, starting clock...`);
      
      // Start the clock for the game
      logger.info(`=== HANDLE INVITE RESPONSE: Starting clock for game ${game.id} ===`);
      await startClock(nsp, game.id);
      logger.info(`=== HANDLE INVITE RESPONSE: Clock started for game ${game.id} ===`);
      
      // ุฅุฑุณุงู ุฅุดุนุงุฑ ููุทุฑููู ุจูุจูู ุงูุฏุนูุฉ ูุน ูุนุฑู ุงููุนุจุฉ
      nsp.to(`user::${invite.from_user_id}`).emit('gameInviteAccepted', {
        inviteId: invite.id,
        gameId: game.id,
        fromUserId: invite.from_user_id,
        toUserId: invite.to_user_id,
        playMethod: invite.play_method,
        gameType: invite.game_type
      });
      
      nsp.to(`user::${invite.to_user_id}`).emit('gameInviteAccepted', {
        inviteId: invite.id,
        gameId: game.id,
        fromUserId: invite.from_user_id,
        toUserId: invite.to_user_id,
        playMethod: invite.play_method,
        gameType: invite.game_type
      });
    } else if (response === 'rejected') {
      // ุชุญุฏูุซ ุญุงูุฉ ุงููุณุชุฎุฏููู ุฅูู offline ุนูุฏ ุงูุฑูุถ
      await Promise.all([
        updateUserStatus(invite.from_user_id, 'offline'),
        updateUserStatus(invite.to_user_id, 'offline')
      ]);
      
      // Broadcast status updates
      nsp.emit('playerStatusChanged', {
        userId: invite.from_user_id,
        status: 'offline'
      });
      nsp.emit('playerStatusChanged', {
        userId: invite.to_user_id,
        status: 'offline'
      });
    }

    // Remove invite from recipient's list
    socket.emit('inviteRemoved', { inviteId });
  } catch (error) {
    logger.error('ุฎุทุฃ ูู ุงูุฑุฏ ุนูู ุฏุนูุฉ ูุนุจ:', error);
    socket.emit('error', { message: error.message });
  }
}

// Game management helpers
export async function startClock(nsp, gameId) {
  try {
    logger.info(`=== STARTCLOCK CALLED for game ${gameId} ===`);
    logger.info(`startClock called for game ${gameId} - checking if already running`);
    
    // ุงูุชุญูู ูู ูุฌูุฏ ูุคูุช ูุดุท ุจุงููุนู
    if (gameTimers[gameId]) {
      logger.info(`Clock already running for game ${gameId}, not starting again`);
      return;
    }

    // ูุฑุงุกุฉ ุจูุงูุงุช ุงููุนุจุฉ ูู ูุงุนุฏุฉ ุงูุจูุงูุงุช ูุฑุฉ ูุงุญุฏุฉ ููุท
    const game = await Game.findByPk(gameId);
    if (!game) {
      logger.error(`Game ${gameId} not found when starting clock`);
      return;
    }

    logger.info(`Game ${gameId} found - status: ${game.status}, white_time_left: ${game.white_time_left}, black_time_left: ${game.black_time_left}, current_turn: ${game.current_turn}`);

    // ุชุฎุฒูู ุจูุงูุงุช ุงููุคูุช ูู ุงูุฐุงูุฑุฉ
    gameTimerData.set(gameId, {
      whiteTimeLeft: game.white_time_left,
      blackTimeLeft: game.black_time_left,
      currentTurn: game.current_turn,
      game: game
    });

    logger.info(`Timer data stored in memory for game ${gameId}:`, {
      whiteTimeLeft: game.white_time_left,
      blackTimeLeft: game.black_time_left,
      currentTurn: game.current_turn
    });

    logger.info(`Setting up setInterval for game ${gameId} - will run every 1000ms`);
    
    // ุฅุฑุณุงู ุชุญุฏูุซ ููุฑู ูููุคูุช
    logger.info(`=== EMITTING IMMEDIATE CLOCK UPDATE for game ${gameId} ===`);
    nsp.to(`game::${gameId}`).emit('clockUpdate', {
      whiteTimeLeft: game.white_time_left,
      blackTimeLeft: game.black_time_left,
      currentTurn: game.current_turn
    });
    logger.info(`=== IMMEDIATE CLOCK UPDATE EMITTED for game ${gameId} ===`);

    // ุฅูุดุงุก ุงููุคูุช
    const timer = setInterval(async () => {
      try {
        logger.info(`=== CLOCK TICK STARTED for game ${gameId} ===`);
        logger.info(`Timer ID: ${timer}, Interval running for game ${gameId}`);
        
        // ุงูุญุตูู ุนูู ุจูุงูุงุช ุงููุคูุช ูู ุงูุฐุงูุฑุฉ
        const timerData = gameTimerData.get(gameId);
        if (!timerData) {
          logger.error(`Timer data not found for game ${gameId}, stopping clock`);
          clearInterval(timer);
          delete gameTimers[gameId];
          return;
        }

        const { whiteTimeLeft, blackTimeLeft, currentTurn } = timerData;
        
        logger.info(`Clock tick for game ${gameId} - current turn: ${currentTurn}`);
        logger.info(`Game ${gameId} current state:`, { whiteTimeLeft, blackTimeLeft, currentTurn });
        logger.info(`Room name: game::${gameId}`);
        logger.info(`Active timers:`, Object.keys(gameTimers));
        logger.info(`Timer data keys:`, Array.from(gameTimerData.keys()));
        
        // ุชุฎููุถ ููุช ุงููุงุนุจ ุงูุญุงูู
        let newWhiteTime = whiteTimeLeft;
        let newBlackTime = blackTimeLeft;
        let newCurrentTurn = currentTurn;
        
        if (currentTurn === 'white') {
          newWhiteTime = Math.max(0, whiteTimeLeft - 1);
          logger.info(`Decreased white time from ${whiteTimeLeft} to ${newWhiteTime}`);
          
          // ุงูุชุญูู ูู ุงูุชูุงุก ุงูููุช
          if (newWhiteTime === 0) {
            logger.info(`White player ran out of time in game ${gameId}`);
            await handleGameTimeout(nsp, gameId, 'white');
            return;
          }
        } else if (currentTurn === 'black') {
          newBlackTime = Math.max(0, blackTimeLeft - 1);
          logger.info(`Decreased black time from ${blackTimeLeft} to ${newBlackTime}`);
          
          // ุงูุชุญูู ูู ุงูุชูุงุก ุงูููุช
          if (newBlackTime === 0) {
            logger.info(`Black player ran out of time in game ${gameId}`);
            await handleGameTimeout(nsp, gameId, 'black');
            return;
          }
        }
        
        // ุชุญุฏูุซ ุงูุจูุงูุงุช ูู ุงูุฐุงูุฑุฉ
        gameTimerData.set(gameId, {
          ...timerData,
          whiteTimeLeft: newWhiteTime,
          blackTimeLeft: newBlackTime
        });
        
        logger.info(`Updated timer data in memory for game ${gameId}:`, {
          whiteTimeLeft: newWhiteTime,
          blackTimeLeft: newBlackTime,
          currentTurn: currentTurn
        });
        
        // ุชุญุฏูุซ ูุงุนุฏุฉ ุงูุจูุงูุงุช ูุน retry mechanism
        let dbUpdateSuccess = false;
        let retryCount = 0;
        const maxRetries = 3;
        
        while (!dbUpdateSuccess && retryCount < maxRetries) {
          try {
            const { updateGameTimeService } = await import('../services/gameService.js');
            const updateResult = await updateGameTimeService(gameId, {
              whiteTimeLeft: newWhiteTime,
              blackTimeLeft: newBlackTime,
              currentTurn: currentTurn
            });
            
            if (updateResult.success) {
              logger.info(`Database updated successfully for game ${gameId}:`, {
                whiteTimeLeft: newWhiteTime,
                blackTimeLeft: newBlackTime,
                currentTurn: currentTurn
              });
              dbUpdateSuccess = true;
            } else {
              logger.error(`Failed to update database for game ${gameId}:`, updateResult.message);
              retryCount++;
              if (retryCount < maxRetries) {
                await new Promise(resolve => setTimeout(resolve, 1000)); // ุงูุชุธุงุฑ ุซุงููุฉ ูุจู ุงููุญุงููุฉ ูุฑุฉ ุฃุฎุฑู
              }
            }
          } catch (dbError) {
            logger.error(`Error updating database for game ${gameId} (attempt ${retryCount + 1}):`, dbError);
            retryCount++;
            if (retryCount < maxRetries) {
              await new Promise(resolve => setTimeout(resolve, 1000)); // ุงูุชุธุงุฑ ุซุงููุฉ ูุจู ุงููุญุงููุฉ ูุฑุฉ ุฃุฎุฑู
            }
          }
        }
        
        // ุฅุฑุณุงู ุงูุชุญุฏูุซ ููุนููุงุก ุญุชู ูู ูุดู ุชุญุฏูุซ ูุงุนุฏุฉ ุงูุจูุงูุงุช
        logger.info(`=== EMITTING CLOCK UPDATE for game ${gameId} ===`);
        logger.info(`Emitting to room: game::${gameId}`);
        logger.info(`Data being emitted:`, {
          whiteTimeLeft: newWhiteTime,
          blackTimeLeft: newBlackTime,
          currentTurn: currentTurn
        });
        
        nsp.to(`game::${gameId}`).emit('clockUpdate', {
          whiteTimeLeft: newWhiteTime,
          blackTimeLeft: newBlackTime,
          currentTurn: currentTurn
        });
        
        // Also emit to individual players to ensure delivery
        const game = await Game.findByPk(gameId);
        if (game && game.white_player_id) {
          logger.info(`=== EMITTING CLOCK UPDATE to white player ${game.white_player_id} ===`);
          nsp.to(`user::${game.white_player_id}`).emit('clockUpdate', {
            whiteTimeLeft: newWhiteTime,
            blackTimeLeft: newBlackTime,
            currentTurn: currentTurn
          });
        }
        if (game && game.black_player_id) {
          logger.info(`=== EMITTING CLOCK UPDATE to black player ${game.black_player_id} ===`);
          nsp.to(`user::${game.black_player_id}`).emit('clockUpdate', {
            whiteTimeLeft: newWhiteTime,
            blackTimeLeft: newBlackTime,
            currentTurn: currentTurn
          });
        }
        
        logger.info(`=== CLOCK UPDATE EMITTED for game ${gameId} ===`);
        logger.info(`=== CLOCK TICK COMPLETED for game ${gameId} ===`);
        
      } catch (error) {
        logger.error(`Error in clock tick for game ${gameId}:`, error);
        logger.info(`=== CLOCK TICK FAILED for game ${gameId} ===`);
        
        // ุฅุนุงุฏุฉ ุชุดุบูู ุงููุคูุช ูู ุญุงูุฉ ุงูุฎุทุฃ
        logger.info(`Restarting clock for game ${gameId} due to error`);
        clearInterval(timer);
        delete gameTimers[gameId];
        setTimeout(() => {
          startClock(nsp, gameId).catch(err => {
            logger.error(`Failed to restart clock for game ${gameId}:`, err);
          });
        }, 5000); // ุงูุชุธุงุฑ 5 ุซูุงู ูุจู ุฅุนุงุฏุฉ ุงูุชุดุบูู
      }
    }, 1000);
    
    // ุญูุธ ุงููุคูุช
    gameTimers[gameId] = timer;
    logger.info(`Clock started for game ${gameId} - timer ID: ${timer}`);
    
  } catch (error) {
    logger.error(`Error starting clock for game ${gameId}:`, error);
  }
}

export async function stopClock(gameId) {
  try {
    logger.info(`stopClock called for game ${gameId} - checking if timer exists`);
    
    if (gameTimers[gameId]) {
      clearInterval(gameTimers[gameId]);
      delete gameTimers[gameId];
      logger.info(`Clock stopped for game ${gameId}`);
    } else {
      logger.info(`No active timer found for game ${gameId}`);
    }
    
    // ุฅุฒุงูุฉ ุจูุงูุงุช ุงููุคูุช ูู ุงูุฐุงูุฑุฉ
    gameTimerData.delete(gameId);
    
  } catch (error) {
    logger.error(`Error stopping clock for game ${gameId}:`, error);
  }
}

export async function handleGameTimeout(nsp, gameId, timeoutPlayer) {
  try {
    logger.info(`=== HANDLE GAME TIMEOUT: Handling timeout for game ${gameId} ===`);
    
    // ุงูุญุตูู ุนูู ุจูุงูุงุช ุงููุนุจุฉ
    const game = await Game.findByPk(gameId);
    if (!game) {
      logger.error(`Game ${gameId} not found when handling timeout`);
      return;
    }
    
    // ุชุญุฏูุฏ ุงููุงุฆุฒ
    const winner = timeoutPlayer === 'white' ? 'black' : 'white';
    
    // ุชุญุฏูุซ ุญุงูุฉ ุงููุนุจุฉ
    await game.update({
      status: 'completed',
      winner: winner,
      end_reason: 'timeout'
    });
    
    // ุชุญุฏูุซ ูุงุนุฏุฉ ุงูุจูุงูุงุช ุจุงูููุช ุงูููุงุฆู
    try {
      const { updateGameTimeService } = await import('../services/gameService.js');
      const timerData = gameTimerData.get(gameId);
      if (timerData) {
        const updateResult = await updateGameTimeService(gameId, {
          whiteTimeLeft: timerData.whiteTimeLeft,
          blackTimeLeft: timerData.blackTimeLeft,
          currentTurn: timerData.currentTurn
        });
        
        if (updateResult.success) {
          logger.info(`Final time state saved to database for game ${gameId}:`, {
            whiteTimeLeft: timerData.whiteTimeLeft,
            blackTimeLeft: timerData.blackTimeLeft,
            currentTurn: timerData.currentTurn
          });
        } else {
          logger.error(`Failed to save final time state to database for game ${gameId}:`, updateResult.message);
        }
      }
    } catch (dbError) {
      logger.error(`Error saving final time state to database for game ${gameId}:`, dbError);
    }
    
    // ุฅููุงู ุงููุคูุช
    await stopClock(gameId);
    
    // ุฅุฑุณุงู ุญุฏุซ ุงูุชูุงุก ุงููุนุจุฉ
    nsp.to(`game::${gameId}`).emit('gameTimeout', {
      gameId: gameId,
      timeoutPlayer: timeoutPlayer,
      winner: winner
    });
    
    // ุชุญุฏูุซ ุญุงูุฉ ุงููุงุนุจูู
    const whiteUser = await User.findByPk(game.white_player_id);
    const blackUser = await User.findByPk(game.black_player_id);
    
    if (whiteUser) await whiteUser.update({ state: 'online' });
    if (blackUser) await blackUser.update({ state: 'online' });
    
    logger.info(`Game ${gameId} ended due to timeout - ${timeoutPlayer} player lost`);
    
  } catch (error) {
    logger.error(`Error handling game timeout for game ${gameId}:`, error);
  }
}

// Update current turn when a move is made
export async function updateGameTurn(nsp, gameId, newTurn) {
  try {
    // ุชุญุฏูุซ ุงูุฏูุฑ ูู ูุงุนุฏุฉ ุงูุจูุงูุงุช
    const game = await Game.findByPk(gameId);
    if (game) {
      await game.update({ current_turn: newTurn });
    }
    
    // ุชุญุฏูุซ ุงูุจูุงูุงุช ูู ุงูุฐุงูุฑุฉ
    const timerData = gameTimerData.get(gameId);
    if (timerData) {
      gameTimerData.set(gameId, {
        ...timerData,
        currentTurn: newTurn
      });
    }
    
    // ุชุญุฏูุซ ูุงุนุฏุฉ ุงูุจูุงูุงุช ุนุจุฑ updateGameTimeService ุฃูุถุงู
    try {
      const { updateGameTimeService } = await import('../services/gameService.js');
      const updateResult = await updateGameTimeService(gameId, {
        whiteTimeLeft: timerData?.whiteTimeLeft || 0,
        blackTimeLeft: timerData?.blackTimeLeft || 0,
        currentTurn: newTurn
      });
      
      if (updateResult.success) {
        logger.info(`Database updated successfully for turn change in game ${gameId}:`, {
          currentTurn: newTurn
        });
      } else {
        logger.error(`Failed to update database for turn change in game ${gameId}:`, updateResult.message);
      }
    } catch (dbError) {
      logger.error(`Error updating database for turn change in game ${gameId}:`, dbError);
    }
    
    // ุฅุฑุณุงู ุญุฏุซ ุชุบููุฑ ุงูุฏูุฑ
    nsp.to(`game::${gameId}`).emit('turnUpdate', {
      gameId: gameId,
      currentTurn: newTurn
    });
    
    logger.info(`Turn updated for game ${gameId} to ${newTurn}`);
    
  } catch (error) {
    logger.error(`Error updating game turn for game ${gameId}:`, error);
  }
}

// Handle game move and update turn
export async function handleGameMove(nsp, gameId, moveData) {
  try {
    logger.info(`Processing move for game ${gameId}:`, moveData);
    
    // ุงูุญุตูู ุนูู ุจูุงูุงุช ุงููุนุจุฉ
    const game = await Game.findByPk(gameId);
    if (!game) {
      logger.error(`Game ${gameId} not found when processing move`);
      return;
    }
    
    // ุชุญุฏูุซ FEN ูุงูุฏูุฑ ูู ูุงุนุฏุฉ ุงูุจูุงูุงุช
    const newTurn = moveData.currentTurn || (game.current_turn === 'white' ? 'black' : 'white');
    await game.update({
      current_fen: moveData.fen,
      current_turn: newTurn
    });
    
    // ุชุญุฏูุซ ุงูุจูุงูุงุช ูู ุงูุฐุงูุฑุฉ
    const timerData = gameTimerData.get(gameId);
    if (timerData) {
      gameTimerData.set(gameId, {
        ...timerData,
        currentTurn: newTurn
      });
    }
    
    // Get room members before emitting
    const roomMembers = nsp.adapter.rooms.get(`game::${gameId}`);
    const memberCount = roomMembers ? roomMembers.size : 0;
    logger.info(`=== HANDLE GAME MOVE: Room members before emit: ${memberCount}`);
    logger.info(`=== HANDLE GAME MOVE: Room members details:`, roomMembers ? Array.from(roomMembers) : []);
    logger.info(`=== HANDLE GAME MOVE: All available rooms:`, Array.from(nsp.adapter.rooms.keys()));
    
    // ุฅุฑุณุงู ุญุฏุซ ุงูุญุฑูุฉ
    logger.info(`=== HANDLE GAME MOVE: Emitting moveMade for game ${gameId} ===`);
    const moveMadeData = {
      gameId: gameId,
      move: moveData.san,
      fen: moveData.fen,
      movedBy: moveData.movedBy,
      currentTurn: newTurn,
      timestamp: Date.now()
    };
    logger.info(`=== HANDLE GAME MOVE: moveMade data:`, moveMadeData);
    
    // Always emit moveMade, even if room seems empty (players might be joining)
    logger.info(`=== HANDLE GAME MOVE: Emitting moveMade to room game::${gameId} ===`);
    nsp.to(`game::${gameId}`).emit('moveMade', moveMadeData);
    logger.info(`=== HANDLE GAME MOVE: moveMade emitted for game ${gameId} ===`);
    
    // Also emit to individual players to ensure delivery
    if (game.white_player_id) {
      logger.info(`=== HANDLE GAME MOVE: Emitting moveMade to white player ${game.white_player_id} ===`);
      nsp.to(`user::${game.white_player_id}`).emit('moveMade', moveMadeData);
      logger.info(`=== HANDLE GAME MOVE: moveMade sent to white player ${game.white_player_id} ===`);
    }
    if (game.black_player_id) {
      logger.info(`=== HANDLE GAME MOVE: Emitting moveMade to black player ${game.black_player_id} ===`);
      nsp.to(`user::${game.black_player_id}`).emit('moveMade', moveMadeData);
      logger.info(`=== HANDLE GAME MOVE: moveMade sent to black player ${game.black_player_id} ===`);
    }
    
    // ุฅุฑุณุงู ุญุฏุซ ุชุบููุฑ ุงูุฏูุฑ
    logger.info(`=== HANDLE GAME MOVE: Emitting turnUpdate for game ${gameId} ===`);
    const turnUpdateData = {
      gameId: gameId,
      currentTurn: newTurn,
      timestamp: Date.now(),
      lastMove: moveData.san
    };
    logger.info(`=== HANDLE GAME MOVE: turnUpdate data:`, turnUpdateData);
    nsp.to(`game::${gameId}`).emit('turnUpdate', turnUpdateData);
    logger.info(`=== HANDLE GAME MOVE: turnUpdate emitted for game ${gameId} ===`);
    
    // ุฅุฑุณุงู ุญุฏุซ ุชุฃููุฏ ุงูุญุฑูุฉ ููุงุนุจ ุงูุฐู ูุงู ุจุงูุญุฑูุฉ
    logger.info(`=== HANDLE GAME MOVE: Emitting moveConfirmed for game ${gameId} ===`);
    const moveConfirmedData = {
      gameId: gameId,
      move: moveData.san,
      timestamp: Date.now()
    };
    logger.info(`=== HANDLE GAME MOVE: moveConfirmed data:`, moveConfirmedData);
    
    // Send moveConfirmed to the specific user who made the move
    if (moveData.movedBy === 'white' && game.white_player_id) {
      nsp.to(`user::${game.white_player_id}`).emit('moveConfirmed', moveConfirmedData);
      logger.info(`=== HANDLE GAME MOVE: moveConfirmed sent to white player ${game.white_player_id} ===`);
    } else if (moveData.movedBy === 'black' && game.black_player_id) {
      nsp.to(`user::${game.black_player_id}`).emit('moveConfirmed', moveConfirmedData);
      logger.info(`=== HANDLE GAME MOVE: moveConfirmed sent to black player ${game.black_player_id} ===`);
    }
    
    // ุจุฏุก ุงููุคูุช ุฅุฐุง ูู ููู ูุนูู
    logger.info(`Checking if clock is running for game ${gameId} - gameTimers keys:`, Object.keys(gameTimers));
    if (!gameTimers[gameId]) {
      logger.info(`Clock not running for game ${gameId}, starting it`);
      await startClock(nsp, gameId);
    }
    
    logger.info(`Move processed successfully for game ${gameId}`);
    
  } catch (error) {
    logger.error(`Error processing move for game ${gameId}:`, error);
  }
}

// Cleanup helpers
export async function cleanupExpiredInvites(nsp) {
  try {
    const oneHourAgo = new Date(Date.now() - 60 * 60 * 1000);
    
    const expiredInvites = await Invite.findAll({
      where: {
        status: {
          [Op.or]: ['pending', null]
        },
        date_time: {
          [Op.lt]: oneHourAgo
        }
      }
    });
    
    if (expiredInvites.length > 0) {
      await Invite.update(
        { status: 'expired' },
        {
          where: {
            id: expiredInvites.map(invite => invite.id)
          }
        }
      );
      
      for (const invite of expiredInvites) {
        await updateUserStatus(invite.from_user_id, 'offline');
        await updateUserStatus(invite.to_user_id, 'offline');
        
        nsp.to(`user::${invite.from_user_id}`).emit('inviteExpired', { 
          inviteId: invite.id,
          fromUserId: invite.from_user_id,
          toUserId: invite.to_user_id
        });
        nsp.to(`user::${invite.to_user_id}`).emit('inviteExpired', { 
          inviteId: invite.id,
          fromUserId: invite.from_user_id,
          toUserId: invite.to_user_id
        });
      }
      
      logger.info(`ุชู ุชุญุฏูุซ ${expiredInvites.length} ุฏุนูุฉ ููุชููุฉ ุงูุตูุงุญูุฉ`);
    }
  } catch (error) {
    logger.error('ุฎุทุฃ ูู ุชูุธูู ุงูุฏุนูุงุช ุงูููุชููุฉ:', error);
  }
}

// Monitoring and debugging functions
export function getConnectionStats() {
  const stats = {
    totalUsers: activeUsers.size,
    totalConnections: 0,
    userDetails: []
  };
  
  for (const [userId, connections] of activeUsers.entries()) {
    stats.totalConnections += connections.size;
    stats.userDetails.push({
      userId,
      connectionsCount: connections.size,
      socketIds: Array.from(connections)
    });
  }
  
  return stats;
}

export function logConnectionStats() {
  const stats = getConnectionStats();
  
  // ุทุจุงุนุฉ ุงูุฅุญุตุงุฆูุงุช ููุท ุฅุฐุง ูุงู ููุงู ุชุบููุฑ ูููุนูู
  const hasChanged = stats.totalUsers !== previousStats.totalUsers || 
                    stats.totalConnections !== previousStats.totalConnections;
  
  if (hasChanged && LOG_CONFIG.showStats) {
    if (stats.totalUsers > 0) {
      logger.info('๐ ุฅุญุตุงุฆูุงุช ุงูุงุชุตุงูุงุช:', {
        ูุณุชุฎุฏููู: stats.totalUsers,
        ุงุชุตุงูุงุช: stats.totalConnections
      });
      
      // ุทุจุงุนุฉ ุชูุงุตูู ุงููุณุชุฎุฏููู ููุท ุฅุฐุง ูุงู ููุงู ุฃูุซุฑ ูู ูุณุชุฎุฏู ูุงุญุฏ
      if (stats.userDetails.length > 1) {
        logger.info('๐ฅ ุชูุงุตูู ุงููุณุชุฎุฏููู:');
        stats.userDetails.forEach(user => {
          const icon = user.connectionsCount > 1 ? '๐ฑ' : '๐ป';
          logger.debug(`  ${icon} ุงููุณุชุฎุฏู ${user.userId}: ${user.connectionsCount} ุงุชุตุงู`);
        });
      }
    } else {
      logger.info('๐ด ูุง ููุฌุฏ ูุณุชุฎุฏููู ูุชุตููู ุญุงููุงู');
    }
    
    // ุชุญุฏูุซ ุงูุฅุญุตุงุฆูุงุช ุงูุณุงุจูุฉ
    previousStats = { totalUsers: stats.totalUsers, totalConnections: stats.totalConnections };
  }
}

// ุฏุงูุฉ ูุชุญุฏูุซ ุญุงูุฉ ุงููุณุชุฎุฏู ุนูุฏ ุงูุงูุณุญุงุจ
export async function updateUserStatusAfterResign(gameId, resignedUserId) {
  try {
    // ุงูุจุญุซ ุนู ุงููุจุงุฑุงุฉ
    const game = await Game.findByPk(gameId);
    if (!game) {
      logger.error('ุงููุจุงุฑุงุฉ ุบูุฑ ููุฌูุฏุฉ:', gameId);
      return;
    }
    
    // ุงูุชุญูู ูู ุญุงูุฉ ุงููุงุนุจูู ูุจู ุงูุชุญุฏูุซ
    const [resignedUser, otherUser] = await Promise.all([
      User.findByPk(resignedUserId),
      User.findByPk(game.white_player_id === resignedUserId ? game.black_player_id : game.white_player_id)
    ]);
    
    if (!resignedUser || !otherUser) {
      logger.error('ุฃุญุฏ ุงููุงุนุจูู ุบูุฑ ููุฌูุฏ:', { resignedUserId, otherUserId: game.white_player_id === resignedUserId ? game.black_player_id : game.white_player_id });
      return;
    }
    
    const otherUserId = game.white_player_id === resignedUserId ? game.black_player_id : game.white_player_id;
    const updatePromises = [];
    
    // ุชุญุฏูุซ ุญุงูุฉ ุงููุงุนุจ ุงูููุณุญุจ ุฅูู online
    if (resignedUser.state === 'in-game') {
      // ุงูุชุญูู ูู ุนุฏู ูุฌูุฏ ูุจุงุฑุงุฉ ูุดุทุฉ ุฃุฎุฑู ููุงุนุจ ุงูููุณุญุจ
      const activeGame = await Game.findOne({
        where: {
          [Op.or]: [
            { white_player_id: resignedUserId },
            { black_player_id: resignedUserId }
          ],
          status: {
            [Op.in]: ['in-game', 'in_progress']
          },
          id: { [Op.ne]: gameId }
        }
      });
      
      if (!activeGame) {
        updatePromises.push(updateUserStatus(resignedUserId, 'online'));
      }
    }
    
    // ุชุญุฏูุซ ุญุงูุฉ ุงููุงุนุจ ุงูุขุฎุฑ ุฅูู online ุฃูุถุงู
    if (otherUser.state === 'in-game') {
      // ุงูุชุญูู ูู ุนุฏู ูุฌูุฏ ูุจุงุฑุงุฉ ูุดุทุฉ ุฃุฎุฑู ููุงุนุจ ุงูุขุฎุฑ
      const activeGame = await Game.findOne({
        where: {
          [Op.or]: [
            { white_player_id: otherUserId },
            { black_player_id: otherUserId }
          ],
          status: {
            [Op.in]: ['in-game', 'in_progress']
          },
          id: { [Op.ne]: gameId }
        }
      });
      
      if (!activeGame) {
        updatePromises.push(updateUserStatus(otherUserId, 'online'));
      }
    }
    
    if (updatePromises.length > 0) {
      await Promise.all(updatePromises);
      logger.info(`๐ ุชู ุชุญุฏูุซ ุญุงูุฉ ุงููุงุนุจูู ุจุนุฏ ุงูุงูุณุญุงุจ ูู ุงููุจุงุฑุงุฉ ${gameId}`);
    } else {
      logger.debug(`โน๏ธ ูุง ุญุงุฌุฉ ูุชุญุฏูุซ ุญุงูุฉ ุงููุงุนุจูู ุจุนุฏ ุงูุงูุณุญุงุจ ูู ุงููุจุงุฑุงุฉ ${gameId} - ูุฏููู ูุจุงุฑูุงุช ุฃุฎุฑู ูุดุทุฉ`);
    }
  } catch (error) {
    logger.error('ุฎุทุฃ ูู ุชุญุฏูุซ ุญุงูุฉ ุงููุณุชุฎุฏููู ุจุนุฏ ุงูุงูุณุญุงุจ:', error);
  }
}

// ุฏุงูุฉ ูุชุญุฏูุซ ุญุงูุฉ ุงููุณุชุฎุฏู ุนูุฏ ุงูุชูุงุก ุงููุจุงุฑุงุฉ
export async function updateUserStatusAfterGameEnd(gameId) {
  try {
    // ุงูุจุญุซ ุนู ุงููุจุงุฑุงุฉ
    const game = await Game.findByPk(gameId);
    if (!game) {
      logger.error('ุงููุจุงุฑุงุฉ ุบูุฑ ููุฌูุฏุฉ:', gameId);
      return;
    }
    
    // ุงูุชุญูู ูู ุญุงูุฉ ุงููุงุนุจูู ูุจู ุงูุชุญุฏูุซ
    const [whiteUser, blackUser] = await Promise.all([
      User.findByPk(game.white_player_id),
      User.findByPk(game.black_player_id)
    ]);
    
    if (!whiteUser || !blackUser) {
      logger.error('ุฃุญุฏ ุงููุงุนุจูู ุบูุฑ ููุฌูุฏ:', { whiteUserId: game.white_player_id, blackUserId: game.black_player_id });
      return;
    }
    
    // ุชุญุฏูุซ ุญุงูุฉ ุงููุงุนุจูู ุฅูู online ููุท ุฅุฐุง ูู ูููููุง ูู ูุจุงุฑุงุฉ ุฃุฎุฑู
    const updatePromises = [];
    
    if (whiteUser.state === 'in-game') {
      // ุงูุชุญูู ูู ุนุฏู ูุฌูุฏ ูุจุงุฑุงุฉ ูุดุทุฉ ุฃุฎุฑู ููุงุนุจ ุงูุฃุจูุถ
      const activeGame = await Game.findOne({
        where: {
          [Op.or]: [
            { white_player_id: game.white_player_id },
            { black_player_id: game.white_player_id }
          ],
          status: {
            [Op.in]: ['in-game', 'in_progress']
          },
          id: { [Op.ne]: gameId }
        }
      });
      
      if (!activeGame) {
        updatePromises.push(updateUserStatus(game.white_player_id, 'online'));
      }
    }
    
    if (blackUser.state === 'in-game') {
      // ุงูุชุญูู ูู ุนุฏู ูุฌูุฏ ูุจุงุฑุงุฉ ูุดุทุฉ ุฃุฎุฑู ููุงุนุจ ุงูุฃุณูุฏ
      const activeGame = await Game.findOne({
        where: {
          [Op.or]: [
            { white_player_id: game.black_player_id },
            { black_player_id: game.black_player_id }
          ],
          status: {
            [Op.in]: ['in-game', 'in_progress']
          },
          id: { [Op.ne]: gameId }
        }
      });
      
      if (!activeGame) {
        updatePromises.push(updateUserStatus(game.black_player_id, 'online'));
      }
    }
    
    if (updatePromises.length > 0) {
      await Promise.all(updatePromises);
      logger.info(`๐ ุชู ุชุญุฏูุซ ุญุงูุฉ ุงููุงุนุจูู ุจุนุฏ ุงูุชูุงุก ุงููุจุงุฑุงุฉ ${gameId}`);
    } else {
      logger.debug(`โน๏ธ ูุง ุญุงุฌุฉ ูุชุญุฏูุซ ุญุงูุฉ ุงููุงุนุจูู ุจุนุฏ ุงูุชูุงุก ุงููุจุงุฑุงุฉ ${gameId} - ูุฏููู ูุจุงุฑูุงุช ุฃุฎุฑู ูุดุทุฉ`);
    }
  } catch (error) {
    logger.error('ุฎุทุฃ ูู ุชุญุฏูุซ ุญุงูุฉ ุงููุณุชุฎุฏููู ุจุนุฏ ุงูุชูุงุก ุงููุจุงุฑุงุฉ:', error);
  }
}

// ุฏุงูุฉ ูุชูุธูู ุญุงูุงุช ุงููุณุชุฎุฏููู ุงููุชุฑููุฉ
export async function cleanupOrphanedUserStates() {
  try {
    logger.info('๐ ุจุฏุก ุชูุธูู ุญุงูุงุช ุงููุณุชุฎุฏููู ุงููุชุฑููุฉ...');
    
    // ุงูุจุญุซ ุนู ุงููุณุชุฎุฏููู ุงูุฐูู ุญุงูุชูู in-game
    const inGameUsers = await User.findAll({
      where: { state: 'in-game' }
    });
    
    let cleanedCount = 0;
    
    for (const user of inGameUsers) {
      // ุงูุจุญุซ ุนู ูุจุงุฑุงุฉ ูุดุทุฉ ูููุณุชุฎุฏู
      const activeGame = await Game.findOne({
        where: {
          [Op.or]: [
            { white_player_id: user.user_id },
            { black_player_id: user.user_id }
          ],
          status: {
            [Op.in]: ['in-game', 'in_progress']
          }
        }
      });
      
      // ุฅุฐุง ูู ุชูุฌุฏ ูุจุงุฑุงุฉ ูุดุทุฉุ ุชุญุฏูุซ ุงูุญุงูุฉ ุฅูู online
      if (!activeGame) {
        await User.update(
          { state: 'online' },
          { where: { user_id: user.user_id } }
        );
        logger.info(`๐งน ุชู ุชูุธูู ุญุงูุฉ ุงููุณุชุฎุฏู ${user.user_id} ูู in-game ุฅูู online`);
        cleanedCount++;
      }
    }
    
    logger.info(`โ ุชู ุชูุธูู ${cleanedCount} ุญุงูุฉ ูุณุชุฎุฏู ูุชุฑููุฉ`);
    return cleanedCount;
  } catch (error) {
    logger.error('ุฎุทุฃ ูู ุชูุธูู ุญุงูุงุช ุงููุณุชุฎุฏููู ุงููุชุฑููุฉ:', error);
    return 0;
  }
}

// ุฏุงูุฉ ูุชูุธูู ุญุงูุงุช ุงููุณุชุฎุฏููู ุงูุฐูู ูุฏููู ุญุงูุฉ online ูููููู ุบูุฑ ูุชุตููู
export async function cleanupOrphanedOnlineStates() {
  try {
    logger.info('๐ ุจุฏุก ุชูุธูู ุญุงูุงุช ุงููุณุชุฎุฏููู ุงููุชุตููู ุงููุชุฑููุฉ...');
    
    // ุงูุจุญุซ ุนู ุงููุณุชุฎุฏููู ุงูุฐูู ุญุงูุชูู online
    const onlineUsers = await User.findAll({
      where: { state: 'online' }
    });
    
    let cleanedCount = 0;
    
    for (const user of onlineUsers) {
      // ุงูุชุญูู ูู ูุฌูุฏ ุงุชุตุงู socket ูุนูู
      if (!isUserOnline(user.user_id)) {
        await User.update(
          { state: 'offline' },
          { where: { user_id: user.user_id } }
        );
        logger.info(`๐งน ุชู ุชูุธูู ุญุงูุฉ ุงููุณุชุฎุฏู ${user.user_id} ูู online ุฅูู offline`);
        cleanedCount++;
      }
    }
    
    logger.info(`โ ุชู ุชูุธูู ${cleanedCount} ุญุงูุฉ ูุณุชุฎุฏู ูุชุตู ูุชุฑููุฉ`);
    return cleanedCount;
  } catch (error) {
    logger.error('ุฎุทุฃ ูู ุชูุธูู ุญุงูุงุช ุงููุณุชุฎุฏููู ุงููุชุตููู ุงููุชุฑููุฉ:', error);
    return 0;
  }
}

// ุฏุงูุฉ ูุฅุนุฏุงุฏ ping/pong ููุชุญูู ูู ุงูุงุชุตุงู
export function setupPingPong(socket, userId) {
  // ุฅุฑุณุงู ping ูู 30 ุซุงููุฉ
  const pingInterval = setInterval(() => {
    if (socket.connected) {
      socket.emit('ping');
    } else {
      clearInterval(pingInterval);
    }
  }, 30000);

  // ุงูุงุณุชูุงุน ููู pong
  socket.on('pong', () => {
    // ุงูุงุชุตุงู ูุดุท - ูุง ุญุงุฌุฉ ูุทุจุงุนุฉ ุฃู ุดูุก
  });

  // ุชูุธูู ุนูุฏ ุงูุงููุตุงู
  socket.on('disconnect', () => {
    clearInterval(pingInterval);
  });

  return pingInterval;
}

// Health check for timers
export async function checkTimerHealth() {
  try {
    logger.info('=== TIMER HEALTH CHECK STARTED ===');
    logger.info('Active timers:', Object.keys(gameTimers));
    logger.info('Timer data keys:', Array.from(gameTimerData.keys()));
    
    for (const [gameId, timer] of Object.entries(gameTimers)) {
      const timerData = gameTimerData.get(gameId);
      if (!timerData) {
        logger.error(`Timer data missing for game ${gameId}, cleaning up`);
        clearInterval(timer);
        delete gameTimers[gameId];
        continue;
      }
      
      // ุงูุชุญูู ูู ุฃู ุงููุนุจุฉ ูุง ุชุฒุงู ูุดุทุฉ
      const game = await Game.findByPk(gameId);
      if (!game || game.status !== 'active') {
        logger.info(`Game ${gameId} is no longer active, stopping timer`);
        clearInterval(timer);
        delete gameTimers[gameId];
        gameTimerData.delete(gameId);
        continue;
      }
      
      logger.info(`Timer for game ${gameId} is healthy`);
    }
    
    logger.info('=== TIMER HEALTH CHECK COMPLETED ===');
  } catch (error) {
    logger.error('Error in timer health check:', error);
  }
}

// Export shared data
export { activeUsers, activeGames, gameTimers };